Elementary level of algorithm:

Binary search:

Recursion for while loop?

While loop! The reason is that we should aviod recursion in engineering project (stack overflow!)
Though it may be easlier, don't use recursion. 
If we can use while loop, use it. 


Some features in question:
1: First/Last of something


Some key points in binary search

1: start = 0   end = len(num) - 1  while start + 1 < end

So once it jumps out of the loop, start == end or start + 1 == end
And it can also help handle first position

2: middle = start + (end - start)//2

3: A[middle] > < == target

4: Check A[start] and A[end] in the end







Binary tree:

1: Binary tree traversal
preorder (root left right), inorder (left root right), postorder (left right root)
They are all depth-first algorithms
And level order traversal is breath-first algorithms
Divide and Conquer

Note: From recursion to non-recursion algorithm, we must use stack structure to help

2: divide-and-conquer applies to:
quick sort
merge sort
most binary tree questions


Two templates:
1: recursion
def function()
    main body
    function(root.left)
    function(root.right)
    
2: divide and conquer
def function()
    main body
    left = function(root.left)
    right = function(root.right)
    merge them together


binary tree BFS (level order traversal)
1: 2 queues
2: 1 queue + dummy notes
3: 1 queue



Linked List:

Dummy node: When the head is not determined (which is a common scenario for linked list questions)
remove duplicates
merge two sorted lists
partitiion list
reverse linked list
etc.

Two pointers:
Linked list cycle







TWO SUM:

if (考虑 A[i] 和 A[j] 满足某个条件)：
    j-- //不用考虑 [i+1, j-1] 和 j 组成的pair
else if (考虑 A[i] 和 A[j] 不满足某个条件)
    i++ //不用考虑 i 和 [i+1, j-1] 组成的pair
    do something
else
    do something
    i++ OR j--
    
这一类通过对撞型指针优化算法，根本上其实就是
证明不用扫描多余状态





Dynamic Programming:
1：确定状态
    最后一步是什么
    子问题是什么
    
2：转移方程

3：初始条件和边界情况

4：计算顺序（递归解法会产生重复计算，动态规划不会）